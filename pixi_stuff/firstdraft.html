<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Defend Your Spot</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #03020a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Courier New', monospace;
    overflow: hidden;
  }
  #game-container canvas {
    display: block;
  }
  #ui {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #00ffe7;
    font-size: 14px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    text-shadow: 0 0 10px #00ffe7;
    text-align: center;
    pointer-events: none;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #444;
    font-size: 11px;
    letter-spacing: 0.15em;
    text-align: center;
  }
</style>
</head>
<body>
<div id="ui"> MMORPG </div>
<div id="game-container"></div>
<div id="controls">A / D or ← / → to orbit &nbsp;|&nbsp; Defend your core</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
<script>
// ─── Constants ───────────────────────────────────────────────────────────────
const W = 700, H = 700;
const WALL_THICKNESS = 14;
const BALL_RADIUS = 10;
const PLAYER_ORBIT_RADIUS = 90;
const PLAYER_ORBIT_SPEED = 0.04; // radians per frame at full speed
const TRIANGLE_SIZE = 22; // half-size / scale
const GOAL_RADIUS = 24;
const STARTING_POINTS = 5;

// ─── Pixi App ─────────────────────────────────────────────────────────────────
const app = new PIXI.Application({
  width: W,
  height: H,
  backgroundColor: 0x03020a,
  antialias: true,
  resolution: window.devicePixelRatio || 1,
  autoDensity: true,
});
document.getElementById('game-container').appendChild(app.view);

// ─── Layers ───────────────────────────────────────────────────────────────────
const bgLayer    = new PIXI.Container();
const gameLayer  = new PIXI.Container();
const uiLayer    = new PIXI.Container();
app.stage.addChild(bgLayer, gameLayer, uiLayer);

// ─── Background grid ──────────────────────────────────────────────────────────
(function drawBg() {
  const g = new PIXI.Graphics();
  const spacing = 40;
  g.lineStyle(0.5, 0x0a0a1a, 1);
  for (let x = 0; x <= W; x += spacing) { g.moveTo(x, 0); g.lineTo(x, H); }
  for (let y = 0; y <= H; y += spacing) { g.moveTo(0, y); g.lineTo(W, y); }
  bgLayer.addChild(g);

  // Corner accents
  const c = new PIXI.Graphics();
  const len = 30;
  c.lineStyle(2, 0x00ffe7, 0.6);
  [[0,0],[W,0],[0,H],[W,H]].forEach(([cx,cy]) => {
    const sx = cx === 0 ? 1 : -1, sy = cy === 0 ? 1 : -1;
    c.moveTo(cx, cy + sy * len); c.lineTo(cx, cy); c.lineTo(cx + sx * len, cy);
  });
  bgLayer.addChild(c);
})();

// ─── Walls ────────────────────────────────────────────────────────────────────
(function drawWalls() {
  const g = new PIXI.Graphics();
  g.lineStyle(WALL_THICKNESS, 0x1a3a3a, 1);
  g.drawRect(WALL_THICKNESS/2, WALL_THICKNESS/2, W - WALL_THICKNESS, H - WALL_THICKNESS);
  // Glow overlay
  const glow = new PIXI.Graphics();
  glow.lineStyle(1, 0x00ffe7, 0.3);
  glow.drawRect(WALL_THICKNESS, WALL_THICKNESS, W - WALL_THICKNESS*2, H - WALL_THICKNESS*2);
  bgLayer.addChild(g, glow);
})();

// ─── Utility ──────────────────────────────────────────────────────────────────
function reflect(vel, normal) {
  // v' = v - 2(v·n)n   (n must be unit vector)
  const len = Math.sqrt(normal.x**2 + normal.y**2);
  const nx = normal.x / len, ny = normal.y / len;
  const dot = vel.x * nx + vel.y * ny;
  return { x: vel.x - 2 * dot * nx, y: vel.y - 2 * dot * ny };
}

function segmentNormal(ax, ay, bx, by) {
  // Outward normal for a segment (perpendicular, pointing "outward" — we'll check sign later)
  const dx = bx - ax, dy = by - ay;
  const len = Math.sqrt(dx*dx + dy*dy);
  return { x: dy / len, y: -dx / len };
}

function pointToSegmentDist(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const lenSq = dx*dx + dy*dy;
  if (lenSq === 0) return { dist: Math.hypot(px-ax, py-ay), t: 0 };
  let t = ((px-ax)*dx + (py-ay)*dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  const cx = ax + t * dx, cy = ay + t * dy;
  return { dist: Math.hypot(px-cx, py-cy), t, cx, cy };
}

// ─── Goal Class ───────────────────────────────────────────────────────────────
class Goal {
  constructor(x, y, playerRef) {
    this.x = x; this.y = y;
    this.player = playerRef;
    this.points = STARTING_POINTS;
    this.radius = GOAL_RADIUS;
    this.flashTimer = 0;

    this.gfx = new PIXI.Graphics();
    this.label = new PIXI.Text(String(this.points), {
      fontFamily: 'Courier New',
      fontSize: 16,
      fill: 0x00ffe7,
      align: 'center',
    });
    this.label.anchor.set(0.5);
    gameLayer.addChild(this.gfx, this.label);
    this.draw();
  }

  draw() {
    const g = this.gfx;
    g.clear();
    const flash = this.flashTimer > 0;
    const baseColor = flash ? 0xff3344 : 0x003333;
    const ringColor = flash ? 0xff6677 : 0x00ffe7;
    const alpha     = flash ? 0.9 : 0.5;

    // Pulsing rings
    g.lineStyle(1.5, ringColor, alpha * 0.5);
    g.drawCircle(this.x, this.y, this.radius + 8);
    g.lineStyle(1, ringColor, alpha * 0.25);
    g.drawCircle(this.x, this.y, this.radius + 16);

    // Core fill
    g.lineStyle(2, ringColor, alpha);
    g.beginFill(baseColor, 0.7);
    g.drawCircle(this.x, this.y, this.radius);
    g.endFill();

    this.label.x = this.x;
    this.label.y = this.y;
    this.label.text = String(this.points);
    this.label.style.fill = flash ? 0xff6677 : 0x00ffe7;
  }

  hit() {
    this.points = Math.max(0, this.points - 1);
    this.flashTimer = 20;
  }

  update() {
    if (this.flashTimer > 0) this.flashTimer--;
    this.draw();
  }

  checkBall(ball) {
    const dx = ball.x - this.x, dy = ball.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < this.radius + ball.radius) {
      this.hit();
      // Bounce ball away from center
      const nx = dx / dist, ny = dy / dist;
      const dot = ball.vx * nx + ball.vy * ny;
      ball.vx -= 2 * dot * nx;
      ball.vy -= 2 * dot * ny;
      // Push out
      const overlap = (this.radius + ball.radius) - dist;
      ball.x += nx * overlap;
      ball.y += ny * overlap;
      return true;
    }
    return false;
  }
}

// ─── Player Class ─────────────────────────────────────────────────────────────
class Player {
  constructor(cx, cy) {
    this.cx = cx; // orbit center (= goal position)
    this.cy = cy;
    this.angle = -Math.PI / 2; // start at top
    this.orbitRadius = PLAYER_ORBIT_RADIUS;
    this.speed = 0;
    this.targetSpeed = 0;
    this.size = TRIANGLE_SIZE;

    // Compute world position
    this.x = cx + Math.cos(this.angle) * this.orbitRadius;
    this.y = cy + Math.sin(this.angle) * this.orbitRadius;

    this.gfx = new PIXI.Graphics();
    this.trailGfx = new PIXI.Graphics();
    gameLayer.addChild(this.trailGfx, this.gfx);

    this.goal = new Goal(cx, cy, this);

    // Input
    this.keys = {};
    window.addEventListener('keydown', e => this.keys[e.code] = true);
    window.addEventListener('keyup',   e => this.keys[e.code] = false);
  }

  getTriangleVerts() {
    // Equilateral triangle: base faces toward home (center), apex points away
    const toCenter = Math.atan2(this.cy - this.y, this.cx - this.x);
    const apex = toCenter + Math.PI; // point away from center

    const apexX = this.x + Math.cos(apex) * this.size;
    const apexY = this.y + Math.sin(apex) * this.size;
    const baseAngle1 = toCenter + Math.PI / 3;  // 60°
    const baseAngle2 = toCenter - Math.PI / 3;
    const base1X = this.x + Math.cos(baseAngle1) * this.size;
    const base1Y = this.y + Math.sin(baseAngle1) * this.size;
    const base2X = this.x + Math.cos(baseAngle2) * this.size;
    const base2Y = this.y + Math.sin(baseAngle2) * this.size;

    return [
      { x: apexX, y: apexY },
      { x: base1X, y: base1Y },
      { x: base2X, y: base2Y },
    ];
  }

  update() {
    // Input
    const left  = this.keys['KeyA'] || this.keys['ArrowLeft'];
    const right = this.keys['KeyD'] || this.keys['ArrowRight'];
    if (left)       this.targetSpeed = -PLAYER_ORBIT_SPEED;
    else if (right) this.targetSpeed =  PLAYER_ORBIT_SPEED;
    else            this.targetSpeed = 0;

    // Smooth acceleration
    this.speed += (this.targetSpeed - this.speed) * 0.18;
    this.angle += this.speed;

    this.x = this.cx + Math.cos(this.angle) * this.orbitRadius;
    this.y = this.cy + Math.sin(this.angle) * this.orbitRadius;

    this.goal.update();
    this.draw();
  }

  draw() {
    const g = this.gfx;
    g.clear();
    const verts = this.getTriangleVerts();

    // Orbit path (faint)
    g.lineStyle(0.5, 0x00ffe7, 0.08);
    g.drawCircle(this.cx, this.cy, this.orbitRadius);

    // Triangle glow shadow
    g.lineStyle(6, 0x00ffe7, 0.08);
    g.beginFill(0x002222, 0.5);
    g.moveTo(verts[0].x, verts[0].y);
    g.lineTo(verts[1].x, verts[1].y);
    g.lineTo(verts[2].x, verts[2].y);
    g.closePath();
    g.endFill();

    // Triangle main
    g.lineStyle(2, 0x00ffe7, 0.95);
    g.beginFill(0x004444, 0.6);
    g.moveTo(verts[0].x, verts[0].y);
    g.lineTo(verts[1].x, verts[1].y);
    g.lineTo(verts[2].x, verts[2].y);
    g.closePath();
    g.endFill();

    // Apex highlight dot
    g.lineStyle(0);
    g.beginFill(0x00ffe7, 0.9);
    g.drawCircle(verts[0].x, verts[0].y, 2.5);
    g.endFill();
  }

  // Check collision with ball — only test the two "shield" edges (not the base)
  checkBall(ball) {
    const verts = this.getTriangleVerts();
    const apex = verts[0], b1 = verts[1], b2 = verts[2];

    // Two shield edges: apex→base1, apex→base2
    // (base edge faces home, we skip it — ball coming from outside won't hit base)
    const edges = [
      [apex, b1],
      [apex, b2],
      [b1, b2],  // base edge — still check for correctness
    ];

    let hit = false;
    for (const [ea, eb] of edges) {
      const result = pointToSegmentDist(ball.x, ball.y, ea.x, ea.y, eb.x, eb.y);
      if (result.dist < ball.radius) {
        // Compute normal, ensure it points toward ball
        let n = segmentNormal(ea.x, ea.y, eb.x, eb.y);
        const toBall = { x: ball.x - result.cx, y: ball.y - result.cy };
        if (n.x * toBall.x + n.y * toBall.y < 0) { n.x = -n.x; n.y = -n.y; }

        // Only bounce if ball moving toward face
        const approach = ball.vx * (-n.x) + ball.vy * (-n.y);
        if (approach > 0) {
          const newVel = reflect({ x: ball.vx, y: ball.vy }, n);
          ball.vx = newVel.x;
          ball.vy = newVel.y;

          // Push out of edge
          const overlap = ball.radius - result.dist;
          ball.x += n.x * overlap;
          ball.y += n.y * overlap;
          hit = true;
          break;
        }
      }
    }
    return hit;
  }
}

// ─── Ball Class ───────────────────────────────────────────────────────────────
class Ball {
  constructor(x, y, vx, vy) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.radius = BALL_RADIUS;
    this.speed = Math.sqrt(vx*vx + vy*vy); // maintain constant speed

    this.trail = [];
    this.maxTrail = 12;

    this.gfx = new PIXI.Graphics();
    this.trailGfx = new PIXI.Graphics();
    gameLayer.addChild(this.trailGfx, this.gfx);
  }

  update() {
    // Move
    this.x += this.vx;
    this.y += this.vy;

    // Normalize speed (prevent drift)
    const spd = Math.sqrt(this.vx**2 + this.vy**2);
    if (spd > 0) { this.vx = this.vx / spd * this.speed; this.vy = this.vy / spd * this.speed; }

    // Wall bounce
    const inner = WALL_THICKNESS;
    if (this.x - this.radius < inner) { this.x = inner + this.radius; this.vx = Math.abs(this.vx); }
    if (this.x + this.radius > W - inner) { this.x = W - inner - this.radius; this.vx = -Math.abs(this.vx); }
    if (this.y - this.radius < inner) { this.y = inner + this.radius; this.vy = Math.abs(this.vy); }
    if (this.y + this.radius > H - inner) { this.y = H - inner - this.radius; this.vy = -Math.abs(this.vy); }

    // Trail
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > this.maxTrail) this.trail.shift();

    this.draw();
  }

  draw() {
    // Trail
    const t = this.trailGfx;
    t.clear();
    for (let i = 1; i < this.trail.length; i++) {
      const alpha = (i / this.trail.length) * 0.4;
      const radius = (i / this.trail.length) * this.radius * 0.8;
      t.lineStyle(0);
      t.beginFill(0xff6600, alpha);
      t.drawCircle(this.trail[i].x, this.trail[i].y, radius);
      t.endFill();
    }

    // Ball
    const g = this.gfx;
    g.clear();
    // Glow
    g.lineStyle(0);
    g.beginFill(0xff6600, 0.15);
    g.drawCircle(this.x, this.y, this.radius * 2.2);
    g.endFill();
    // Core
    g.beginFill(0xff6600, 0.2);
    g.drawCircle(this.x, this.y, this.radius * 1.3);
    g.endFill();
    g.lineStyle(2, 0xff9944, 1);
    g.beginFill(0xff6600, 0.9);
    g.drawCircle(this.x, this.y, this.radius);
    g.endFill();
    // Specular
    g.lineStyle(0);
    g.beginFill(0xffffff, 0.5);
    g.drawCircle(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.3);
    g.endFill();
  }
}

// ─── Game Setup ───────────────────────────────────────────────────────────────
const player = new Player(W / 2, H / 2);
const ball   = new Ball(
  W * 0.25,
  H * 0.3,
  3.2, 2.6
);

// ─── HUD ──────────────────────────────────────────────────────────────────────
const hudText = new PIXI.Text('', {
  fontFamily: 'Courier New',
  fontSize: 12,
  fill: 0x336655,
  align: 'left',
});
hudText.x = WALL_THICKNESS + 8;
hudText.y = WALL_THICKNESS + 8;
uiLayer.addChild(hudText);

// Game over text
const gameOverText = new PIXI.Text('', {
  fontFamily: 'Courier New',
  fontSize: 28,
  fill: 0xff3344,
  align: 'center',
  letterSpacing: 6,
});
gameOverText.anchor.set(0.5);
gameOverText.x = W / 2;
gameOverText.y = H / 2 - 30;
gameOverText.visible = false;
uiLayer.addChild(gameOverText);

const restartText = new PIXI.Text('[ PRESS R TO RESTART ]', {
  fontFamily: 'Courier New',
  fontSize: 13,
  fill: 0x00ffe7,
  align: 'center',
  letterSpacing: 3,
});
restartText.anchor.set(0.5);
restartText.x = W / 2;
restartText.y = H / 2 + 14;
restartText.visible = false;
uiLayer.addChild(restartText);

// ─── Game State ───────────────────────────────────────────────────────────────
let gameOver = false;
let frameCount = 0;

window.addEventListener('keydown', e => {
  if (e.code === 'KeyR' && gameOver) restartGame();
});

function restartGame() {
  gameOver = false;
  player.goal.points = STARTING_POINTS;
  player.goal.flashTimer = 0;
  player.angle = -Math.PI / 2;
  player.speed = 0;
  ball.x = W * 0.25; ball.y = H * 0.3;
  ball.vx = 3.2; ball.vy = 2.6;
  ball.trail = [];
  gameOverText.visible = false;
  restartText.visible = false;
}

// ─── Game Loop ────────────────────────────────────────────────────────────────
app.ticker.add(() => {
  frameCount++;

  if (!gameOver) {
    player.update();
    ball.update();
    player.checkBall(ball);
    player.goal.checkBall(ball);

    hudText.text = `ORBIT SPEED: ${Math.abs(player.speed).toFixed(3)}`;

    if (player.goal.points <= 0) {
      gameOver = true;
      gameOverText.text = 'BASE DESTROYED';
      gameOverText.visible = true;
      restartText.visible = true;
    }
  } else {
    // Flicker restart hint
    restartText.alpha = 0.5 + 0.5 * Math.sin(frameCount * 0.08);
  }
});
</script>
</body>
</html>